# Инструкция для работы с Git и удалёнными репозиториями

![git logo](https://git-scm.com/images/logo@2x.png "GIT logi")

Что такое Git? Git - это одна из реализаций распределённых систем контроля версий, имеющая как и локальные, так и удалённые репозитории. Является самой популярной реализацией систем контроля версий в мире. В этом файле мы рассмотрим основы работы с гит и с удалёнными репозиториями (на примере GitHub).

Как работает гит? Каждый раз, когда мы сохраняем состояние проекта, Git запоминает как выглядит каждый файл в этот момент времени, как бы делая снимок всего проекта (замораживая его) и сохраняет ссылку на этот снимок, его еще можно назвать коммитом (commit).

![Alt text](image.png)

Каждый раз, когда Вы делаете коммит, Git сначала вычисляет хеш сумму этого коммита и только потом сохраняет информацию. При этом в коммите есть ссылка на предыдущий коммит - его хеш сумма. Так Git обеспечивает целостность истории изменений. Поэтому даже если кто-то хоть что-нибудь изменит в любом коммите из цепочки, его хеш сумма полностью изменится и придется переписывать уже всю последующую историю коммитов, что не останется незамеченным.

![Alt text](image-1.png)

# Разделы инструкции:

- [Настройка git](#настройка-git)
- [Подготовка репозитория](#подготовка-репозитория)
- [Создание коммитов](#создание-коммитов)
- [Перемещение между сохранениями](#перемещение-между-сохранениями)
- [Журнал изменений](#журнал-изменений)
- [Ветки в Git](#ветки-в-git)
- [Создание репозитория GitHub](#создание-репозитория)
- [Работа с удалённым репозиторием](#работа-с-удалённым-репозиторием)
- [Предложение и вливание изменений в сторонний репозиторий](#предложение-и-вливание-изменений-в-сторонний-репозиторий)

# Настройка git

После установки гита мы можем проверить его версию:

```
git --version
```


Чтобы получить помощь по командам git, нужно ввести следующую команду:

```
git --help
```

Также перед началом работы с гитом надо указать свои данные (для того, чтобы он мог впоследствие проводить коммиты и заливать данные на удаленный сервер GitHub). Данные можно указать, грубо говоря, в три разные "зоны видимости":

- "git config --system" - для всех пользователей системы настройки
- "git config --global" - настройки для конкретного пользователя
- "git config --local" - настройки для текущего репозитория


```
git config --global user.name "Ваш юзернейм"
git config --global user.email "Ваш email"
```

Впоследствии можно проверить, какой сейчас юзернейм и емейл, вбив такую же команду, только без указания данных:

```
git config --global user.name
git config --global user.email
```

# Запись изменений в репозиторий

Что такое репозиторий? Это хранилище файлов, которое поддерживает версионность; просто корневая папка с файлами и вложенными директориями вашей программы. Загрузить в репозиторий можно всё что угодно, но предполагается, что вы будете хранить в нём файлы с исходным кодом и какие-нибудь дополнительные материалы — допустим, необходимую для GUI или вёрстки графику (картинки, иконки и тому подобное).

Для создание репозитория необходимо выполнить команду `git init` в папке с репозиторием, и у вас создастся репозиторий (появится скрытая папка `.git`)

Причем неважно, создаём ли мы репозиторий в пустой папке, или создаём его в папке с уже существующими файлами. Это команда - команда гиту, что надо начать отслеживание файлов в этом каталоге

## git status

Для того, чтобы посмотреть состояние репозитория используется команда `git status`. Для этого необходимо в папке с репозиторием написать `git status`, и вы увидите были ли измения в файлах, или их не было.

Если мы сделали git status в пустой папке, то мы увидим следующее:

```
C:\Users\user1\Desktop\git_edu>git status
On branch master

No commits yet

nothing to commit (create/copy files and use "git add" to track)
```

1) Мы находимся в ветке master
2) Нет никаких коммитов
3) Нечего коммитить

Далее. Допустим, мы создали в репозитории файл file1.md и сохранили его. Пишем команду git status. Что мы увидим?

```
On branch master

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        file1.md

nothing added to commit but untracked files present (use "git add" to track)
```

1) Мы находимся в мастер ветке
2) Пока нет никаких коммитов - мы не зафиксировали никаких изменений
3) Есть **неотслеживаемый файл** - тот, который мы только что добавили

То есть статус файла, который мы добавили - неотслеживаемый (`untracked`). А какие вообще статусы могут быть у файлов в git?

1) `untracked` - это файлы, которые не отслеживаются гитом (просто висят в папке, грубо говоря)
2) `tracked` - отслеживаемые
	1) `staged` - это файлы, которые были добавлены в индекс с помощью git add (грубо говоря, добавлены в "корзину"), для того, чтобы потом их закоммитить. То есть такое, положение "готовности" для коммита
	2) `commited` - это файлы, которые закоммичены
	3) `modified` - это когда файл (уже ранее закоммиченный или новый который был добавлен в индекс) был изменён, но ещё не попал в коммит

![Alt text](image-2.png)

## Git add

Для того, чтобы закоммитить файл, надо сначала добавить его "в корзину" - в индекс. Делается это с помощью команды `git add`. Чтобы использовать команду `git add`, напишите `git add <имя файла>`.

> Чтобы добавить сразу все unstaged/modified файлы в индекс (то есть сделать их staged) можно не писать каждый файл git add <имя файла>, а просто написать:
> 
> git add .

## git commit

Когда ваш индекс ("корзина") находится в таком состоянии, как вам и хотелось, вы можете зафиксировать свои изменения. Запомните, всё, что до сих пор не проиндексировано — любые файлы, созданные или изменённые вами, и для которых вы не выполнили `git add` после редактирования — не войдут в этот коммит. Они останутся изменёнными файлами на вашем диске. Простейший способ зафиксировать изменения — это набрать `git commit`. Выполняется она так: `git commit -m "<сообщение к коммиту>"`. Все файлы для коммита должны быть ДОБАВЛЕНЫ и сообщение к коммиту писать ОБЯЗАТЕЛЬНО.

Если мы после этого внесём изменения в файл и снова закоммитим, у нас появится второй коммит, который будет ссылаться на первый; потом создадим ещё один - тогда третий будет ссылаться на второй и так далее. Таким образом, у нас создаётся цепочка из коммитов.

# Перемещение между сохранениями (версиями)

## Журнал изменений

Для того, чтобы посмтреть все сделанные изменения в репозитории, используется команда `git log`. Она выдаст нам весь список изменений, где наверху будет самый последний коммит, а внизу - самый первый. В каждом коммите нам покажет:

1) Автора изменений
2) Дату изменений
3) Хэш-сумму коммита
4) Сообщение коммита

## git checkout

Для того, чтобы перемещаться между коммитами, используется команда `git checkout`. Используется она в папке с репозиторием следующим образом: `git checkout <номер коммита>`

После введения этой команды, git автоматически вернёт нам состояние рабочего каталога на момент указанного коммита: все изменения, котоыре мы сделали после этого коммита, все новые файлы и папки - ничего этого в этом коммите не будет.

Помни, что чтобы дальше работать с репозиторием, нам надо вернуться в его актуальное состояние (то есть в последний коммит). Для того, чтобы вернуться в последний коммит, надо написать следующую команду: `git checkout master` (если мы находимся в ветке master; про работу с ветками читай ниже).

# Ветки в Git

## Создание веток

Структура Git представлена в виде дерева - есть одна главная ветка с изменениями (по умолчанию она, обычно, называется master), от которой могут отходить другие ветки (в которых тоже находятся изменения). Если у нас одна ветка коммитов, то каждый коммит просто ссылается на свой родительский коммит:

![Alt text](image-3.png)

Чтобы проверить, в какой ветке мы находимся (и какие ветки вообще есть в репозитории), надо написать команду `git branch` (звёздочка указывает на текущую ветку).

```
git branch
  main
* redaction
```

При введении команды `git log`, о которой мы говорили ранее, указатель HEAD показывает не только на коммит, но и на ветку:

![Alt text](image-4.png)

Когда мы создаём новую ветку (c помощью команды `git branch <название ветки>`), она добавляется на последний коммит

![Alt text](image-5.png)

Чтобы перейти на вновь созданную ветку, надо написать команду `git checkout <название ветки>`:

![Alt text](image-6.png)

Когда мы добавляем коммиты в новую ветку, указатель HEAD вместе с указателем ветки перемещается вперёд - а указатель изначальной ветки (из которой мы отвели новую), остаётся как бы "позади":

![Alt text](image-7.png)

Если мы напишем команду `git checkout master`, то состояние репозитория вернётся на состояние последнего коммита в ветке `master`, а все изменения, которые мы внесли в ветку `new-api` в этом примере, нам видны не будут:

![Alt text](image-8.png)

Если мы теперь сделаем новый коммит, но уже в ветке `master`, структура нашего git будет выглядеть вот так:

![Alt text](image-9.png)

## Слияние веток

Для того чтобы добавить ветку в текущую ветку используется команда `git merge`. Допустим мы делаем merge с веткой bugfix (merge пишется из той ветки, В КОТОРУЮ мы хотим добавить новую инфу; то есть если мы хотим в мастер добавить информацию из bugfix, надо сначала перейти в ветку master)

![Alt text](image-10.png)


В данном случае, так как последний коммит ветки master являлся прямым родителем последнего коммита ветки bugfix, мы просто переместили голову ветки master на последний коммит bugfix'a

![Alt text](image-11.png)

После такого ветка bugfix нам больше не нужна, и мы можем её удалить: `git branch -d bugfix`. А что если мы теперь захотим слить ветку master с веткой new-api? Простым переносом (fast forward) мы больше этого сделать не сможем, так как в таком случае мы больше не можем сдвинуть указатель мастера вперёд, так как последний коммит мастера больше не является прямым родителем последнего коммита new-api.

Чтобы теперь слить ветки master и new-api команда делаем ту же - `git merge`, но путь теперь будет немного другой.

![Alt text](image-12.png)

Мы видим теперь, что у нового коммита теперь два родителя (два родительских коммита) вместо одного. Такой коммит называется merge commit.

## Merge конфликты

Иногда слияние происходит гладко (без конфликтов). Но что если в разных ветках один и тот же текст написан по разному? Когда мы эти ветки будем сливать у нас возникнет конфликт - гит не поймет, какую из этих версий надо использовать. При merge конфликте гит автоматически не сможет соединить коммиты, и предложит нам решить их вручную. Мы можем выбрать один из следующих вариантов:

- `Accept Current Change` - сохранить то, что находится в ветке, в которую мы вливаем данные
- `Accept Incoming Change` - сохранить то, что "пришло" из другой ветки
- `Accept Both Changes` - сохранить оба изменения

Также мы можем вручную полностью изменить текст и сохранить его - это тоже будет решением merge конфликта.

После того, как мы в редакторе вручную разрешили конфликт, надо файл сохранить. Разрешив каждый конфликт во всех файлах, запустите `git add` для каждого файла, чтобы отметить конфликт как решённый. Добавление файла в индекс означает для Git, что все конфликты в нём исправлены.

Если вас всё устраивает — выполните команду `git commit` для создания коммита слияния.

> Merge-конфликты довольно часто возникают в работе, поэтому у проекта должен быть один ответственный человек, который будет заниматься слиянием веток

# Работа с удалёнными репозиториями

Git - это локальная система. А GitHub - это удаленная система, которая позволяет сразу нескольким разработчикам работать над одним проектом.

В репозиториях GitHub можно хранить различные проекты, включая проекты с открытым исходным кодом. С проектами с открытым исходным кодом вы можете обмениваться кодом для создания лучшего и более надежного программного обеспечения. Вы можете использовать репозитории для совместной работы с другими пользователями и отслеживания своей работы.

* В правом верхнем углу любой страницы воспользуйтесь  выпадающим меню и выберите Новый репозиторий.

![](https://docs.github.com/assets/cb-31554/mw-1440/images/help/repository/repo-create.webp)

* Введите короткое, запоминающееся название для вашего репозитория. Например, "hello-world".

![](https://docs.github.com/assets/cb-61138/mw-1440/images/help/repository/create-repository-name.webp)

* При желании добавьте описание вашего репозитория. Например, "Мой первый репозиторий на GitHub".
* Выберите видимость репозитория. (публичный или приватный)
* Нажмите Создать репозиторий.

## Связь локального и удалённого репозитория

Чтобы связать свой локальный репозиторий с удалённым репозиторием, надо сделать следующее (ссылка создаётся при создании удалённого репозитория, которое мы обсудили выше):

`git remote add origin <ссылка на удалённый репозиторий>`

Чтобы теперь проверить, с чем связан наш локальный репозиторий, можно вбить команду `git remote -v`, которая покажет нам, с какими удалёнными серверами связан наш локальный

```
PS C:\Users\user1\Desktop\github_info> git remote -v
origin  https://github.com/user1/git-info.git (fetch)
origin  https://github.com/user1/git-info.git (push)
```

Как мы видим, у нас есть два сервера - один для забирания данных (fetch), другой для их отправки (push). По умолчанию они одинаковые.

## git push

После создания удалённого репозитория надо отправить данные со своего локального репозитория на удалённый. Делается это с помощью следующей команды: `git push`. Если мы напишем следующую команду, она будет означать "отправь на сервер origin локальную ветку с названием master и создай там её копию".

`git push --set-upstream origin master`

После отправки локального репозитория на удалённом, у нас появятся так называемые ветки слежения. Ветки слежения - это ссылки на определённое состояние удалённых веток.

![Alt text](image-13.png)

> При первом использовании команды `git push` будет необходима авторизация на внешнем репозитории.

Помимо "заливания" своего репозитория на пустой удалённый сервер, команда `git push` используется для того, чтобы залить изменения, которые мы сделали на локальном репозитории, на уже существующий удалённый, с которым этот локальный связан. То есть если мы внесём изменения в наш проект, для того чтобы они появились на удалённом репозитории надо будет повторно написать команду `git push`.

## Клонирование репозитория

Вопрос - как теперь этот код из репозитория передать другому человеку? Если репозиторий публичный достаточно будет просто передать ему ссылку. Если репозиторий приватный, тогда надо пригласить людей в наш репозиторий (в настройках - manage access). Так вот, человек просто копирует ссылку из зелёной кнопки "code" и делает следующее (в своей папке):

`git clone <ссылка на репозиторий>`

>Команда git clone составная: она не только загружает все изменения, но и пытается слить все ветки на локальном компьютере (если они есть) и в удаленном репозитории.

## git pull

Чтобы скачать изменения из удалённого репозитория необходимо выполнить команду `git pull`

>Эта команда позволяет скачать все из текущего репозитория и автоматически сделать merge с нашей версией

До команды `git pull`:

![Alt text](image-14.png)

После команды `git pull`:

![Alt text](image-15.png)

> По своей сути, команда `git pull` является составной, и выполняет поочерёдно две следующие команды: `git fetch` ("закачивает" недостающие изменения с удалённого репозитория) + `git merge` (делает merge)

# Предложение и вливание изменений в сторонний репозиторий

В больших компаниях один ответственный за проект создает аккаунт. Другие пользователи дают команду `pull request`. Предлагать изменения на GitHub нужно в отдельной ветке. Сначала пользователь копирует репозиторий на свой компьютер, делает fork репозитория, затем клонирует версию на своём ПК, создаёт ветку с предлагаемыми изменениями, отправляет изменения командой push в свой аккаунт на GitHub и даёт команду `pull request`.

## pull request

Что такое pull request?

* команда для предложения изменений
* запрос на вливание изменений в репозиторий

Как сделать pull request?

* Делаем ответвление репозитория с помощью **fork**
* Делаем `git clone` свой версии репозитория
* Создаем новую ветку и в НЕЕ вносим свои изменения
* Фиксируем изменения (делаем коммиты)
* Отправляем свою версию в свой GitHub
* На сайте GitHub нажимаем кнопку **pull request**